/**
 * Order Repository (Edge Functions版)
 * orders テーブルのCRUD操作
 *
 * Auto-generated by HEADLESS API Generator
 * - BaseRepository継承
 * - RLS対応（userClient使用）
 * - エラーハンドリング統一
 */

import { BaseRepository } from '../repository.ts'

export interface Order {
  id: string
  user_id: string
  created_at: string
  updated_at: string
  stripe_checkout_session_id: string
  stripe_payment_intent_id: string
  status: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
  total_amount: number
  currency: string
  metadata: Record<string, any>
  fulfilled_at: string
}

export interface OrderInsert {
  user_id: string
  user_id?: string | null
  stripe_checkout_session_id?: string | null
  stripe_payment_intent_id?: string | null
  status: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
  total_amount: number
  currency: string
  metadata?: Record<string, any> | null
  fulfilled_at?: string | null
}

export interface OrderUpdate {
  stripe_checkout_session_id?: string
  stripe_payment_intent_id?: string
  status?: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
  total_amount?: number
  currency?: string
  metadata?: Record<string, any>
  fulfilled_at?: string
}

export class OrderRepository extends BaseRepository {
  /**
   * Get order by ID
   */
  async findById(id: string): Promise<Order | null> {
    const { data, error } = await this.supabase
      .from('orders')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      if (this.isNotFoundError(error)) {
        return null
      }
      throw new Error(`Failed to fetch order: ${error.message}`)
    }

    return data as Order
  }

  /**
   * Get orders by user ID
   */
  async findByUserId(
    userId: string,
    filters?: { status?: any, userId?: any }
  ): Promise<Order[]> {
    let query = this.supabase
      .from('orders')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.userId) {
      query = query.eq('userId', filters.userId)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch user orders: ${error.message}`)
    }

    return (data as Order[]) || []
  }

  /**
   * Get current user's orders
   */
  async findMine(filters?: { status?: any, userId?: any }): Promise<Order[]> {
    const user = await this.getCurrentUser()
    return this.findByUserId(user.id, filters)
  }

  /**
   * Create order
   */
  async create(data: OrderInsert): Promise<Order> {
    const { data: result, error } = await this.supabase
      .from('orders')
      .insert([data])
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create order: ${error.message}`)
    }

    return result as Order
  }

  /**
   * Update order
   */
  async update(id: string, updates: OrderUpdate): Promise<Order> {
    const { data, error } = await this.supabase
      .from('orders')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update order: ${error.message}`)
    }

    return data as Order
  }

  /**
   * Delete order
   */
  async delete(id: string): Promise<void> {
    const { error } = await this.supabase.from('orders').delete().eq('id', id)

    if (error) {
      throw new Error(`Failed to delete order: ${error.message}`)
    }
  }

  /**
   * Get orders with filters
   */
  async findAll(filters?: {
    status?: any
    userId?: any
    limit?: number
  }): Promise<Order[]> {
    let query = this.supabase
      .from('orders')
      .select('*')
      .order('created_at', { ascending: false })
    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.userId) {
      query = query.eq('userId', filters.userId)
    }

    if (filters?.limit) {
      query = query.limit(filters.limit)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch orders: ${error.message}`)
    }

    return (data as Order[]) || []
  }

  /**
   * Get current user's orders
   */
  async my(filters?: { status?: any }): Promise<Order[]> {
    // Custom operation: my
    // TODO: Implement custom logic
    return this.findAll(filters)
  }
}