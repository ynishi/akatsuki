/**
 * Product Repository (Edge Functions版)
 * products テーブルのCRUD操作
 *
 * Auto-generated by HEADLESS API Generator
 * - BaseRepository継承
 * - RLS対応（userClient使用）
 * - エラーハンドリング統一
 */

import { BaseRepository } from '../repository.ts'

export interface Product {
  id: string
  created_at: string
  updated_at: string
  name: string
  description: string
  product_type: 'token_pack' | 'digital' | 'feature' | 'physical'
  stripe_product_id: string
  metadata: Record<string, any>
  image_url: string
  display_order: number
  is_active: boolean
}

export interface ProductInsert {
  user_id: string
  name: string
  description?: string | null
  product_type: 'token_pack' | 'digital' | 'feature' | 'physical'
  stripe_product_id?: string | null
  metadata?: Record<string, any> | null
  image_url?: string | null
  display_order?: number | null
  is_active: boolean
}

export interface ProductUpdate {
  name?: string
  description?: string
  product_type?: 'token_pack' | 'digital' | 'feature' | 'physical'
  stripe_product_id?: string
  metadata?: Record<string, any>
  image_url?: string
  display_order?: number
  is_active?: boolean
}

export class ProductRepository extends BaseRepository {
  /**
   * Get product by ID
   */
  async findById(id: string): Promise<Product | null> {
    const { data, error } = await this.supabase
      .from('products')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      if (this.isNotFoundError(error)) {
        return null
      }
      throw new Error(`Failed to fetch product: ${error.message}`)
    }

    return data as Product
  }

  /**
   * Get products by user ID
   */
  async findByUserId(
    userId: string,
    filters?: { productType?: any, isActive?: any }
  ): Promise<Product[]> {
    let query = this.supabase
      .from('products')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
    if (filters?.productType) {
      query = query.eq('productType', filters.productType)
    }
    if (filters?.isActive) {
      query = query.eq('isActive', filters.isActive)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch user products: ${error.message}`)
    }

    return (data as Product[]) || []
  }

  /**
   * Get current user's products
   */
  async findMine(filters?: { productType?: any, isActive?: any }): Promise<Product[]> {
    const user = await this.getCurrentUser()
    return this.findByUserId(user.id, filters)
  }

  /**
   * Create product
   */
  async create(data: ProductInsert): Promise<Product> {
    const { data: result, error } = await this.supabase
      .from('products')
      .insert([data])
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create product: ${error.message}`)
    }

    return result as Product
  }

  /**
   * Update product
   */
  async update(id: string, updates: ProductUpdate): Promise<Product> {
    const { data, error } = await this.supabase
      .from('products')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update product: ${error.message}`)
    }

    return data as Product
  }

  /**
   * Delete product
   */
  async delete(id: string): Promise<void> {
    const { error } = await this.supabase.from('products').delete().eq('id', id)

    if (error) {
      throw new Error(`Failed to delete product: ${error.message}`)
    }
  }

  /**
   * Get products with filters
   */
  async findAll(filters?: {
    productType?: any
    isActive?: any
    limit?: number
  }): Promise<Product[]> {
    let query = this.supabase
      .from('products')
      .select('*')
      .order('created_at', { ascending: false })
    if (filters?.productType) {
      query = query.eq('productType', filters.productType)
    }
    if (filters?.isActive) {
      query = query.eq('isActive', filters.isActive)
    }

    if (filters?.limit) {
      query = query.limit(filters.limit)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch products: ${error.message}`)
    }

    return (data as Product[]) || []
  }

  /**
   * Get all active products
   */
  async active(filters?: { productType?: any }): Promise<Product[]> {
    // Custom operation: active
    // TODO: Implement custom logic
    return this.findAll(filters)
  }
}