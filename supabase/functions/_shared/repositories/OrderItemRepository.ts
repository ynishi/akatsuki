/**
 * OrderItem Repository (Edge Functions版)
 * order_items テーブルのCRUD操作
 *
 * Auto-generated by HEADLESS API Generator
 * - BaseRepository継承
 * - RLS対応（userClient使用）
 * - エラーハンドリング統一
 */

import { BaseRepository } from '../repository.ts'

export interface OrderItem {
  id: string
  order_id: string
  created_at: string
  product_id: string
  variant_id: string
  product_name: string
  variant_name: string
  quantity: number
  unit_price: number
  subtotal: number
  product_type: string
  product_metadata: Record<string, any>
}

export interface OrderItemInsert {
  user_id: string
  order_id: string
  product_id?: string | null
  variant_id?: string | null
  product_name: string
  variant_name?: string | null
  quantity: number
  unit_price: number
  subtotal: number
  product_type: string
  product_metadata?: Record<string, any> | null
}

export interface OrderItemUpdate {
  order_id?: string
  product_id?: string
  variant_id?: string
  product_name?: string
  variant_name?: string
  quantity?: number
  unit_price?: number
  subtotal?: number
  product_type?: string
  product_metadata?: Record<string, any>
}

export class OrderItemRepository extends BaseRepository {
  /**
   * Get order_item by ID
   */
  async findById(id: string): Promise<OrderItem | null> {
    const { data, error } = await this.supabase
      .from('order_items')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      if (this.isNotFoundError(error)) {
        return null
      }
      throw new Error(`Failed to fetch order_item: ${error.message}`)
    }

    return data as OrderItem
  }

  /**
   * Get order_items by user ID
   */
  async findByUserId(
    userId: string,
    filters?: { orderId?: any }
  ): Promise<OrderItem[]> {
    let query = this.supabase
      .from('order_items')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
    if (filters?.orderId) {
      query = query.eq('orderId', filters.orderId)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch user order_items: ${error.message}`)
    }

    return (data as OrderItem[]) || []
  }

  /**
   * Get current user's order_items
   */
  async findMine(filters?: { orderId?: any }): Promise<OrderItem[]> {
    const user = await this.getCurrentUser()
    return this.findByUserId(user.id, filters)
  }

  /**
   * Create order_item
   */
  async create(data: OrderItemInsert): Promise<OrderItem> {
    const { data: result, error } = await this.supabase
      .from('order_items')
      .insert([data])
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create order_item: ${error.message}`)
    }

    return result as OrderItem
  }

  /**
   * Update order_item
   */
  async update(id: string, updates: OrderItemUpdate): Promise<OrderItem> {
    const { data, error } = await this.supabase
      .from('order_items')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update order_item: ${error.message}`)
    }

    return data as OrderItem
  }

  /**
   * Delete order_item
   */
  async delete(id: string): Promise<void> {
    const { error } = await this.supabase.from('order_items').delete().eq('id', id)

    if (error) {
      throw new Error(`Failed to delete order_item: ${error.message}`)
    }
  }

  /**
   * Get order_items with filters
   */
  async findAll(filters?: {
    orderId?: any
    limit?: number
  }): Promise<OrderItem[]> {
    let query = this.supabase
      .from('order_items')
      .select('*')
      .order('created_at', { ascending: false })
    if (filters?.orderId) {
      query = query.eq('orderId', filters.orderId)
    }

    if (filters?.limit) {
      query = query.limit(filters.limit)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch order_items: ${error.message}`)
    }

    return (data as OrderItem[]) || []
  }
}