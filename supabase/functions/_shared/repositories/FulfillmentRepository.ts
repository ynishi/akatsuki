/**
 * Fulfillment Repository (Edge Functions版)
 * fulfillments テーブルのCRUD操作
 *
 * Auto-generated by HEADLESS API Generator
 * - BaseRepository継承
 * - RLS対応（userClient使用）
 * - エラーハンドリング統一
 */

import { BaseRepository } from '../repository.ts'

export interface Fulfillment {
  id: string
  order_item_id: string
  created_at: string
  fulfillment_type: string
  status: 'pending' | 'completed' | 'failed'
  result: Record<string, any>
  error_message: string
  completed_at: string
}

export interface FulfillmentInsert {
  user_id: string
  order_item_id: string
  fulfillment_type: string
  status: 'pending' | 'completed' | 'failed'
  result?: Record<string, any> | null
  error_message?: string | null
  completed_at?: string | null
}

export interface FulfillmentUpdate {
  order_item_id?: string
  fulfillment_type?: string
  status?: 'pending' | 'completed' | 'failed'
  result?: Record<string, any>
  error_message?: string
  completed_at?: string
}

export class FulfillmentRepository extends BaseRepository {
  /**
   * Get fulfillment by ID
   */
  async findById(id: string): Promise<Fulfillment | null> {
    const { data, error } = await this.supabase
      .from('fulfillments')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      if (this.isNotFoundError(error)) {
        return null
      }
      throw new Error(`Failed to fetch fulfillment: ${error.message}`)
    }

    return data as Fulfillment
  }

  /**
   * Get fulfillments by user ID
   */
  async findByUserId(
    userId: string,
    filters?: { status?: any, fulfillmentType?: any }
  ): Promise<Fulfillment[]> {
    let query = this.supabase
      .from('fulfillments')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.fulfillmentType) {
      query = query.eq('fulfillmentType', filters.fulfillmentType)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch user fulfillments: ${error.message}`)
    }

    return (data as Fulfillment[]) || []
  }

  /**
   * Get current user's fulfillments
   */
  async findMine(filters?: { status?: any, fulfillmentType?: any }): Promise<Fulfillment[]> {
    const user = await this.getCurrentUser()
    return this.findByUserId(user.id, filters)
  }

  /**
   * Create fulfillment
   */
  async create(data: FulfillmentInsert): Promise<Fulfillment> {
    const { data: result, error } = await this.supabase
      .from('fulfillments')
      .insert([data])
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create fulfillment: ${error.message}`)
    }

    return result as Fulfillment
  }

  /**
   * Update fulfillment
   */
  async update(id: string, updates: FulfillmentUpdate): Promise<Fulfillment> {
    const { data, error } = await this.supabase
      .from('fulfillments')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update fulfillment: ${error.message}`)
    }

    return data as Fulfillment
  }

  /**
   * Delete fulfillment
   */
  async delete(id: string): Promise<void> {
    const { error } = await this.supabase.from('fulfillments').delete().eq('id', id)

    if (error) {
      throw new Error(`Failed to delete fulfillment: ${error.message}`)
    }
  }

  /**
   * Get fulfillments with filters
   */
  async findAll(filters?: {
    status?: any
    fulfillmentType?: any
    limit?: number
  }): Promise<Fulfillment[]> {
    let query = this.supabase
      .from('fulfillments')
      .select('*')
      .order('created_at', { ascending: false })
    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.fulfillmentType) {
      query = query.eq('fulfillmentType', filters.fulfillmentType)
    }

    if (filters?.limit) {
      query = query.limit(filters.limit)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch fulfillments: ${error.message}`)
    }

    return (data as Fulfillment[]) || []
  }
}