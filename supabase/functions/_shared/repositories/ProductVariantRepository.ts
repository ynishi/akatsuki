/**
 * ProductVariant Repository (Edge Functions版)
 * product_variants テーブルのCRUD操作
 *
 * Auto-generated by HEADLESS API Generator
 * - BaseRepository継承
 * - RLS対応（userClient使用）
 * - エラーハンドリング統一
 */

import { BaseRepository } from '../repository.ts'

export interface ProductVariant {
  id: string
  product_id: string
  created_at: string
  updated_at: string
  name: string
  price_amount: number
  currency: string
  stripe_price_id: string
  metadata: Record<string, any>
  is_default: boolean
  is_active: boolean
  display_order: number
}

export interface ProductVariantInsert {
  user_id: string
  product_id: string
  name: string
  price_amount: number
  currency: string
  stripe_price_id?: string | null
  metadata?: Record<string, any> | null
  is_default: boolean
  is_active: boolean
  display_order?: number | null
}

export interface ProductVariantUpdate {
  product_id?: string
  name?: string
  price_amount?: number
  currency?: string
  stripe_price_id?: string
  metadata?: Record<string, any>
  is_default?: boolean
  is_active?: boolean
  display_order?: number
}

export class ProductVariantRepository extends BaseRepository {
  /**
   * Get product_variant by ID
   */
  async findById(id: string): Promise<ProductVariant | null> {
    const { data, error } = await this.supabase
      .from('product_variants')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      if (this.isNotFoundError(error)) {
        return null
      }
      throw new Error(`Failed to fetch product_variant: ${error.message}`)
    }

    return data as ProductVariant
  }

  /**
   * Get product_variants by user ID
   */
  async findByUserId(
    userId: string,
    filters?: { productId?: any, isActive?: any }
  ): Promise<ProductVariant[]> {
    let query = this.supabase
      .from('product_variants')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
    if (filters?.productId) {
      query = query.eq('productId', filters.productId)
    }
    if (filters?.isActive) {
      query = query.eq('isActive', filters.isActive)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch user product_variants: ${error.message}`)
    }

    return (data as ProductVariant[]) || []
  }

  /**
   * Get current user's product_variants
   */
  async findMine(filters?: { productId?: any, isActive?: any }): Promise<ProductVariant[]> {
    const user = await this.getCurrentUser()
    return this.findByUserId(user.id, filters)
  }

  /**
   * Create product_variant
   */
  async create(data: ProductVariantInsert): Promise<ProductVariant> {
    const { data: result, error } = await this.supabase
      .from('product_variants')
      .insert([data])
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create product_variant: ${error.message}`)
    }

    return result as ProductVariant
  }

  /**
   * Update product_variant
   */
  async update(id: string, updates: ProductVariantUpdate): Promise<ProductVariant> {
    const { data, error } = await this.supabase
      .from('product_variants')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update product_variant: ${error.message}`)
    }

    return data as ProductVariant
  }

  /**
   * Delete product_variant
   */
  async delete(id: string): Promise<void> {
    const { error } = await this.supabase.from('product_variants').delete().eq('id', id)

    if (error) {
      throw new Error(`Failed to delete product_variant: ${error.message}`)
    }
  }

  /**
   * Get product_variants with filters
   */
  async findAll(filters?: {
    productId?: any
    isActive?: any
    limit?: number
  }): Promise<ProductVariant[]> {
    let query = this.supabase
      .from('product_variants')
      .select('*')
      .order('created_at', { ascending: false })
    if (filters?.productId) {
      query = query.eq('productId', filters.productId)
    }
    if (filters?.isActive) {
      query = query.eq('isActive', filters.isActive)
    }

    if (filters?.limit) {
      query = query.limit(filters.limit)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch product_variants: ${error.message}`)
    }

    return (data as ProductVariant[]) || []
  }

  /**
   * Get variants for a specific product
   */
  async byProduct(filters?: { isActive?: any }): Promise<ProductVariant[]> {
    // Custom operation: byProduct
    // TODO: Implement custom logic
    return this.findAll(filters)
  }
}