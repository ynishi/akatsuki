/**
 * useFulfillments Hook (React Query)
 * Auto-generated by HEADLESS API Generator
 *
 * Manages fulfillments state and CRUD operations
 * - React Query integration
 * - Type-safe mutations
 * - Automatic cache invalidation
 *
 * Usage:
 * ```typescript
 * const { fulfillments, isLoading, createFulfillment, updateFulfillment, deleteFulfillment } = useFulfillments()
 * ```
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { FulfillmentService } from '../services/FulfillmentService'
import { Fulfillment } from '../models/Fulfillment'
import type { FulfillmentStatus } from '../models/Fulfillment'

interface UseFulfillmentsOptions {
  /** Get only current user's fulfillments (default: true) */
  mine?: boolean
  /** Filter by status */
  status?: FulfillmentStatus
  /** Limit number of results */
  limit?: number
  /** Auto-load on mount (default: true) */
  autoLoad?: boolean
}

interface UseFulfillmentsReturn {
  // Query state
  fulfillments: Fulfillment[] | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void

  // Create
  createFulfillment: (data: {
    orderItemId: string
    fulfillmentType: string
    status: 'pending' | 'completed' | 'failed'
    result?: Record<string, any>
    errorMessage?: string
    completedAt?: string
  }) => void
  createFulfillmentAsync: (data: {
    orderItemId: string
    fulfillmentType: string
    status: 'pending' | 'completed' | 'failed'
    result?: Record<string, any>
    errorMessage?: string
    completedAt?: string
  }) => Promise<Fulfillment>
  isCreating: boolean

  // Update
  updateFulfillment: (id: string, data: {
    orderItemId?: string
    fulfillmentType?: string
    status?: 'pending' | 'completed' | 'failed'
    result?: Record<string, any>
    errorMessage?: string
    completedAt?: string
  }) => void
  updateFulfillmentAsync: (id: string, data: {
    orderItemId?: string
    fulfillmentType?: string
    status?: 'pending' | 'completed' | 'failed'
    result?: Record<string, any>
    errorMessage?: string
    completedAt?: string
  }) => Promise<Fulfillment>
  isUpdating: boolean

  // Delete
  deleteFulfillment: (id: string) => void
  deleteFulfillmentAsync: (id: string) => Promise<void>
  isDeleting: boolean

  // Status helpers
  setStatusCompleted: (id: string) => void
  setStatusPending: (id: string) => void

  // Deprecated aliases
  loading: boolean
  refresh: () => void
}

export function useFulfillments(options: UseFulfillmentsOptions = {}): UseFulfillmentsReturn {
  const {
    mine = true,
    status,
    limit = 20,
    autoLoad = true,
  } = options

  const queryClient = useQueryClient()

  // Build query key
  const queryKey = ['fulfillments', { mine, status, limit }]

  /**
   * Query: Fetch fulfillments
   */
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      let result
      if (mine) {
        result = await FulfillmentService.list({ status, limit })
      } else {
        result = await FulfillmentService.list({ status, limit })
      }

      if (result.error) throw result.error
      return result.data?.map((data) => Fulfillment.fromDatabase(data)) || []
    },
    enabled: autoLoad,
  })

  /**
   * Mutation: Create fulfillment
   */
  const createMutation = useMutation({
    mutationFn: async (data: {
      orderItemId: string
      fulfillmentType: string
      status: 'pending' | 'completed' | 'failed'
      result?: Record<string, any>
      errorMessage?: string
      completedAt?: string
    }) => {
      const result = await FulfillmentService.create(data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to create fulfillment')
      return Fulfillment.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['fulfillments'] })
    },
  })

  /**
   * Mutation: Update fulfillment
   */
  const updateMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: {
      orderItemId?: string
      fulfillmentType?: string
      status?: 'pending' | 'completed' | 'failed'
      result?: Record<string, any>
      errorMessage?: string
      completedAt?: string
    } }) => {
      const result = await FulfillmentService.update(id, data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to update fulfillment')
      return Fulfillment.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['fulfillments'] })
    },
  })

  /**
   * Mutation: Delete fulfillment
   */
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await FulfillmentService.delete(id)
      if (result.error) throw result.error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['fulfillments'] })
    },
  })

  /**
   * Mutation: Set status to completed
   */
  const setStatusCompletedMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await FulfillmentService.setStatusCompleted(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set status to completed')
      return Fulfillment.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['fulfillments'] })
    },
  })

  /**
   * Mutation: Set status to pending
   */
  const setStatusPendingMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await FulfillmentService.setStatusPending(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set status to pending')
      return Fulfillment.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['fulfillments'] })
    },
  })

  return {
    // Query state
    fulfillments: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,

    // Create
    createFulfillment: (data) => createMutation.mutate(data),
    createFulfillmentAsync: (data) => createMutation.mutateAsync(data),
    isCreating: createMutation.isPending,

    // Update
    updateFulfillment: (id, data) => updateMutation.mutate({ id, data }),
    updateFulfillmentAsync: (id, data) => updateMutation.mutateAsync({ id, data }),
    isUpdating: updateMutation.isPending,

    // Delete
    deleteFulfillment: (id) => deleteMutation.mutate(id),
    deleteFulfillmentAsync: (id) => deleteMutation.mutateAsync(id),
    isDeleting: deleteMutation.isPending,

    // Status helpers
    setStatusCompleted: (id) => setStatusCompletedMutation.mutate(id),
    setStatusPending: (id) => setStatusPendingMutation.mutate(id),

    // Deprecated aliases
    loading: query.isLoading,
    refresh: query.refetch,
  }
}

/**
 * useFulfillment Hook - Get single fulfillment by ID
 */
export function useFulfillment(id: string, options: { autoLoad?: boolean } = {}) {
  const { autoLoad = true } = options

  const query = useQuery({
    queryKey: ['fulfillment', id],
    queryFn: async () => {
      const result = await FulfillmentService.getById(id)
      if (result.error) throw result.error
      return result.data ? Fulfillment.fromDatabase(result.data) : null
    },
    enabled: !!id && autoLoad,
  })

  return {
    fulfillment: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  }
}