/**
 * useOrders Hook (React Query)
 * Auto-generated by HEADLESS API Generator
 *
 * Manages orders state and CRUD operations
 * - React Query integration
 * - Type-safe mutations
 * - Automatic cache invalidation
 *
 * Usage:
 * ```typescript
 * const { orders, isLoading, createOrder, updateOrder, deleteOrder } = useOrders()
 * ```
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { OrderService } from '../services/OrderService'
import { Order } from '../models/Order'
import type { OrderStatus } from '../models/Order'

interface UseOrdersOptions {
  /** Get only current user's orders (default: true) */
  mine?: boolean
  /** Filter by status */
  status?: OrderStatus
  /** Use 'my' query */
  my?: boolean
  /** Limit number of results */
  limit?: number
  /** Auto-load on mount (default: true) */
  autoLoad?: boolean
}

interface UseOrdersReturn {
  // Query state
  orders: Order[] | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void

  // Create
  createOrder: (data: {
    stripeCheckoutSessionId?: string
    stripePaymentIntentId?: string
    status: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
    totalAmount: number
    currency: string
    metadata?: Record<string, any>
    fulfilledAt?: string
  }) => void
  createOrderAsync: (data: {
    stripeCheckoutSessionId?: string
    stripePaymentIntentId?: string
    status: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
    totalAmount: number
    currency: string
    metadata?: Record<string, any>
    fulfilledAt?: string
  }) => Promise<Order>
  isCreating: boolean

  // Update
  updateOrder: (id: string, data: {
    stripeCheckoutSessionId?: string
    stripePaymentIntentId?: string
    status?: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
    totalAmount?: number
    currency?: string
    metadata?: Record<string, any>
    fulfilledAt?: string
  }) => void
  updateOrderAsync: (id: string, data: {
    stripeCheckoutSessionId?: string
    stripePaymentIntentId?: string
    status?: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
    totalAmount?: number
    currency?: string
    metadata?: Record<string, any>
    fulfilledAt?: string
  }) => Promise<Order>
  isUpdating: boolean

  // Delete
  deleteOrder: (id: string) => void
  deleteOrderAsync: (id: string) => Promise<void>
  isDeleting: boolean

  // Status helpers
  setStatusPaid: (id: string) => void
  setStatusPending: (id: string) => void

  // Deprecated aliases
  loading: boolean
  refresh: () => void
}

export function useOrders(options: UseOrdersOptions = {}): UseOrdersReturn {
  const {
    mine = true,
    status,
    my = false,
    limit = 20,
    autoLoad = true,
  } = options

  const queryClient = useQueryClient()

  // Build query key
  const queryKey = ['orders', { mine, status, my, limit }]

  /**
   * Query: Fetch orders
   */
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      let result
      if (my) {
        result = await OrderService.my()
      }
      else if (mine) {
        result = await OrderService.list({ status, limit })
      } else {
        result = await OrderService.list({ status, limit })
      }

      if (result.error) throw result.error
      return result.data?.map((data) => Order.fromDatabase(data)) || []
    },
    enabled: autoLoad,
  })

  /**
   * Mutation: Create order
   */
  const createMutation = useMutation({
    mutationFn: async (data: {
      stripeCheckoutSessionId?: string
      stripePaymentIntentId?: string
      status: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
      totalAmount: number
      currency: string
      metadata?: Record<string, any>
      fulfilledAt?: string
    }) => {
      const result = await OrderService.create(data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to create order')
      return Order.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orders'] })
    },
  })

  /**
   * Mutation: Update order
   */
  const updateMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: {
      stripeCheckoutSessionId?: string
      stripePaymentIntentId?: string
      status?: 'pending' | 'paid' | 'fulfilled' | 'cancelled' | 'refunded'
      totalAmount?: number
      currency?: string
      metadata?: Record<string, any>
      fulfilledAt?: string
    } }) => {
      const result = await OrderService.update(id, data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to update order')
      return Order.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orders'] })
    },
  })

  /**
   * Mutation: Delete order
   */
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await OrderService.delete(id)
      if (result.error) throw result.error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orders'] })
    },
  })

  /**
   * Mutation: Set status to paid
   */
  const setStatusPaidMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await OrderService.setStatusPaid(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set status to paid')
      return Order.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orders'] })
    },
  })

  /**
   * Mutation: Set status to pending
   */
  const setStatusPendingMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await OrderService.setStatusPending(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set status to pending')
      return Order.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orders'] })
    },
  })

  return {
    // Query state
    orders: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,

    // Create
    createOrder: (data) => createMutation.mutate(data),
    createOrderAsync: (data) => createMutation.mutateAsync(data),
    isCreating: createMutation.isPending,

    // Update
    updateOrder: (id, data) => updateMutation.mutate({ id, data }),
    updateOrderAsync: (id, data) => updateMutation.mutateAsync({ id, data }),
    isUpdating: updateMutation.isPending,

    // Delete
    deleteOrder: (id) => deleteMutation.mutate(id),
    deleteOrderAsync: (id) => deleteMutation.mutateAsync(id),
    isDeleting: deleteMutation.isPending,

    // Status helpers
    setStatusPaid: (id) => setStatusPaidMutation.mutate(id),
    setStatusPending: (id) => setStatusPendingMutation.mutate(id),

    // Deprecated aliases
    loading: query.isLoading,
    refresh: query.refetch,
  }
}

/**
 * useOrder Hook - Get single order by ID
 */
export function useOrder(id: string, options: { autoLoad?: boolean } = {}) {
  const { autoLoad = true } = options

  const query = useQuery({
    queryKey: ['order', id],
    queryFn: async () => {
      const result = await OrderService.getById(id)
      if (result.error) throw result.error
      return result.data ? Order.fromDatabase(result.data) : null
    },
    enabled: !!id && autoLoad,
  })

  return {
    order: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  }
}