/**
 * useProductVariants Hook (React Query)
 * Auto-generated by HEADLESS API Generator
 *
 * Manages productvariants state and CRUD operations
 * - React Query integration
 * - Type-safe mutations
 * - Automatic cache invalidation
 *
 * Usage:
 * ```typescript
 * const { productvariants, isLoading, createProductVariant, updateProductVariant, deleteProductVariant } = useProductVariants()
 * ```
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { ProductVariantService } from '../services/ProductVariantService'
import { ProductVariant } from '../models/ProductVariant'

interface UseProductVariantsOptions {
  /** Get only current user's productvariants (default: true) */
  mine?: boolean
  /** Use 'byProduct' query */
  byProduct?: boolean
  /** Filter for byProduct: isActive */
  isActive?: string
  /** Limit number of results */
  limit?: number
  /** Auto-load on mount (default: true) */
  autoLoad?: boolean
}

interface UseProductVariantsReturn {
  // Query state
  productvariants: ProductVariant[] | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void

  // Create
  createProductVariant: (data: {
    productId: string
    name: string
    priceAmount: number
    currency: string
    stripePriceId?: string
    metadata?: Record<string, any>
    isDefault: boolean
    isActive: boolean
    displayOrder?: number
  }) => void
  createProductVariantAsync: (data: {
    productId: string
    name: string
    priceAmount: number
    currency: string
    stripePriceId?: string
    metadata?: Record<string, any>
    isDefault: boolean
    isActive: boolean
    displayOrder?: number
  }) => Promise<ProductVariant>
  isCreating: boolean

  // Update
  updateProductVariant: (id: string, data: {
    productId?: string
    name?: string
    priceAmount?: number
    currency?: string
    stripePriceId?: string
    metadata?: Record<string, any>
    isDefault?: boolean
    isActive?: boolean
    displayOrder?: number
  }) => void
  updateProductVariantAsync: (id: string, data: {
    productId?: string
    name?: string
    priceAmount?: number
    currency?: string
    stripePriceId?: string
    metadata?: Record<string, any>
    isDefault?: boolean
    isActive?: boolean
    displayOrder?: number
  }) => Promise<ProductVariant>
  isUpdating: boolean

  // Delete
  deleteProductVariant: (id: string) => void
  deleteProductVariantAsync: (id: string) => Promise<void>
  isDeleting: boolean

  // Deprecated aliases
  loading: boolean
  refresh: () => void
}

export function useProductVariants(options: UseProductVariantsOptions = {}): UseProductVariantsReturn {
  const {
    mine = true,
    byProduct = false,
    isActive,
    limit = 20,
    autoLoad = true,
  } = options

  const queryClient = useQueryClient()

  // Build query key
  const queryKey = ['productvariants', { mine, byProduct, limit }]

  /**
   * Query: Fetch productvariants
   */
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      let result
      if (byProduct) {
        result = await ProductVariantService.byProduct({ isActive: isActive })
      }
      else if (mine) {
        result = await ProductVariantService.list({ limit })
      } else {
        result = await ProductVariantService.list({ limit })
      }

      if (result.error) throw result.error
      return result.data?.map((data) => ProductVariant.fromDatabase(data)) || []
    },
    enabled: autoLoad,
  })

  /**
   * Mutation: Create productvariant
   */
  const createMutation = useMutation({
    mutationFn: async (data: {
      productId: string
      name: string
      priceAmount: number
      currency: string
      stripePriceId?: string
      metadata?: Record<string, any>
      isDefault: boolean
      isActive: boolean
      displayOrder?: number
    }) => {
      const result = await ProductVariantService.create(data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to create productvariant')
      return ProductVariant.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['productvariants'] })
    },
  })

  /**
   * Mutation: Update productvariant
   */
  const updateMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: {
      productId?: string
      name?: string
      priceAmount?: number
      currency?: string
      stripePriceId?: string
      metadata?: Record<string, any>
      isDefault?: boolean
      isActive?: boolean
      displayOrder?: number
    } }) => {
      const result = await ProductVariantService.update(id, data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to update productvariant')
      return ProductVariant.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['productvariants'] })
    },
  })

  /**
   * Mutation: Delete productvariant
   */
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await ProductVariantService.delete(id)
      if (result.error) throw result.error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['productvariants'] })
    },
  })

  return {
    // Query state
    productvariants: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,

    // Create
    createProductVariant: (data) => createMutation.mutate(data),
    createProductVariantAsync: (data) => createMutation.mutateAsync(data),
    isCreating: createMutation.isPending,

    // Update
    updateProductVariant: (id, data) => updateMutation.mutate({ id, data }),
    updateProductVariantAsync: (id, data) => updateMutation.mutateAsync({ id, data }),
    isUpdating: updateMutation.isPending,

    // Delete
    deleteProductVariant: (id) => deleteMutation.mutate(id),
    deleteProductVariantAsync: (id) => deleteMutation.mutateAsync(id),
    isDeleting: deleteMutation.isPending,

    // Deprecated aliases
    loading: query.isLoading,
    refresh: query.refetch,
  }
}

/**
 * useProductVariant Hook - Get single productvariant by ID
 */
export function useProductVariant(id: string, options: { autoLoad?: boolean } = {}) {
  const { autoLoad = true } = options

  const query = useQuery({
    queryKey: ['productvariant', id],
    queryFn: async () => {
      const result = await ProductVariantService.getById(id)
      if (result.error) throw result.error
      return result.data ? ProductVariant.fromDatabase(result.data) : null
    },
    enabled: !!id && autoLoad,
  })

  return {
    productvariant: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  }
}