/**
 * useProducts Hook (React Query)
 * Auto-generated by HEADLESS API Generator
 *
 * Manages products state and CRUD operations
 * - React Query integration
 * - Type-safe mutations
 * - Automatic cache invalidation
 *
 * Usage:
 * ```typescript
 * const { products, isLoading, createProduct, updateProduct, deleteProduct } = useProducts()
 * ```
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { ProductService } from '../services/ProductService'
import { Product } from '../models/Product'
import type { ProductProductType } from '../models/Product'

interface UseProductsOptions {
  /** Get only current user's products (default: true) */
  mine?: boolean
  /** Filter by productType */
  productType?: ProductProductType
  /** Use 'active' query */
  active?: boolean
  /** Limit number of results */
  limit?: number
  /** Auto-load on mount (default: true) */
  autoLoad?: boolean
}

interface UseProductsReturn {
  // Query state
  products: Product[] | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void

  // Create
  createProduct: (data: {
    name: string
    description?: string
    productType: 'token_pack' | 'digital' | 'feature' | 'physical'
    stripeProductId?: string
    metadata?: Record<string, any>
    imageUrl?: string
    displayOrder?: number
    isActive: boolean
  }) => void
  createProductAsync: (data: {
    name: string
    description?: string
    productType: 'token_pack' | 'digital' | 'feature' | 'physical'
    stripeProductId?: string
    metadata?: Record<string, any>
    imageUrl?: string
    displayOrder?: number
    isActive: boolean
  }) => Promise<Product>
  isCreating: boolean

  // Update
  updateProduct: (id: string, data: {
    name?: string
    description?: string
    productType?: 'token_pack' | 'digital' | 'feature' | 'physical'
    stripeProductId?: string
    metadata?: Record<string, any>
    imageUrl?: string
    displayOrder?: number
    isActive?: boolean
  }) => void
  updateProductAsync: (id: string, data: {
    name?: string
    description?: string
    productType?: 'token_pack' | 'digital' | 'feature' | 'physical'
    stripeProductId?: string
    metadata?: Record<string, any>
    imageUrl?: string
    displayOrder?: number
    isActive?: boolean
  }) => Promise<Product>
  isUpdating: boolean

  // Delete
  deleteProduct: (id: string) => void
  deleteProductAsync: (id: string) => Promise<void>
  isDeleting: boolean

  // ProductType helpers
  setProductTypeDigital: (id: string) => void
  setProductTypeTokenPack: (id: string) => void

  // Deprecated aliases
  loading: boolean
  refresh: () => void
}

export function useProducts(options: UseProductsOptions = {}): UseProductsReturn {
  const {
    mine = true,
    productType,
    active = false,
    limit = 20,
    autoLoad = true,
  } = options

  const queryClient = useQueryClient()

  // Build query key
  const queryKey = ['products', { mine, productType, active, limit }]

  /**
   * Query: Fetch products
   */
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      let result
      if (active) {
        result = await ProductService.active()
      }
      else if (mine) {
        result = await ProductService.list({ productType, limit })
      } else {
        result = await ProductService.list({ productType, limit })
      }

      if (result.error) throw result.error
      return result.data?.map((data) => Product.fromDatabase(data)) || []
    },
    enabled: autoLoad,
  })

  /**
   * Mutation: Create product
   */
  const createMutation = useMutation({
    mutationFn: async (data: {
      name: string
      description?: string
      productType: 'token_pack' | 'digital' | 'feature' | 'physical'
      stripeProductId?: string
      metadata?: Record<string, any>
      imageUrl?: string
      displayOrder?: number
      isActive: boolean
    }) => {
      const result = await ProductService.create(data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to create product')
      return Product.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] })
    },
  })

  /**
   * Mutation: Update product
   */
  const updateMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: {
      name?: string
      description?: string
      productType?: 'token_pack' | 'digital' | 'feature' | 'physical'
      stripeProductId?: string
      metadata?: Record<string, any>
      imageUrl?: string
      displayOrder?: number
      isActive?: boolean
    } }) => {
      const result = await ProductService.update(id, data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to update product')
      return Product.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] })
    },
  })

  /**
   * Mutation: Delete product
   */
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await ProductService.delete(id)
      if (result.error) throw result.error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] })
    },
  })

  /**
   * Mutation: Set productType to digital
   */
  const setProductTypeDigitalMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await ProductService.setProductTypeDigital(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set productType to digital')
      return Product.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] })
    },
  })

  /**
   * Mutation: Set productType to token_pack
   */
  const setProductTypeTokenPackMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await ProductService.setProductTypeTokenPack(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set productType to token_pack')
      return Product.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] })
    },
  })

  return {
    // Query state
    products: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,

    // Create
    createProduct: (data) => createMutation.mutate(data),
    createProductAsync: (data) => createMutation.mutateAsync(data),
    isCreating: createMutation.isPending,

    // Update
    updateProduct: (id, data) => updateMutation.mutate({ id, data }),
    updateProductAsync: (id, data) => updateMutation.mutateAsync({ id, data }),
    isUpdating: updateMutation.isPending,

    // Delete
    deleteProduct: (id) => deleteMutation.mutate(id),
    deleteProductAsync: (id) => deleteMutation.mutateAsync(id),
    isDeleting: deleteMutation.isPending,

    // ProductType helpers
    setProductTypeDigital: (id) => setProductTypeDigitalMutation.mutate(id),
    setProductTypeTokenPack: (id) => setProductTypeTokenPackMutation.mutate(id),

    // Deprecated aliases
    loading: query.isLoading,
    refresh: query.refetch,
  }
}

/**
 * useProduct Hook - Get single product by ID
 */
export function useProduct(id: string, options: { autoLoad?: boolean } = {}) {
  const { autoLoad = true } = options

  const query = useQuery({
    queryKey: ['product', id],
    queryFn: async () => {
      const result = await ProductService.getById(id)
      if (result.error) throw result.error
      return result.data ? Product.fromDatabase(result.data) : null
    },
    enabled: !!id && autoLoad,
  })

  return {
    product: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  }
}