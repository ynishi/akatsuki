/**
 * useOrderItems Hook (React Query)
 * Auto-generated by HEADLESS API Generator
 *
 * Manages orderitems state and CRUD operations
 * - React Query integration
 * - Type-safe mutations
 * - Automatic cache invalidation
 *
 * Usage:
 * ```typescript
 * const { orderitems, isLoading, createOrderItem, updateOrderItem, deleteOrderItem } = useOrderItems()
 * ```
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { OrderItemService } from '../services/OrderItemService'
import { OrderItem } from '../models/OrderItem'

interface UseOrderItemsOptions {
  /** Get only current user's orderitems (default: true) */
  mine?: boolean
  /** Limit number of results */
  limit?: number
  /** Auto-load on mount (default: true) */
  autoLoad?: boolean
}

interface UseOrderItemsReturn {
  // Query state
  orderitems: OrderItem[] | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void

  // Create
  createOrderItem: (data: {
    orderId: string
    productId?: string
    variantId?: string
    productName: string
    variantName?: string
    quantity: number
    unitPrice: number
    subtotal: number
    productType: string
    productMetadata?: Record<string, any>
  }) => void
  createOrderItemAsync: (data: {
    orderId: string
    productId?: string
    variantId?: string
    productName: string
    variantName?: string
    quantity: number
    unitPrice: number
    subtotal: number
    productType: string
    productMetadata?: Record<string, any>
  }) => Promise<OrderItem>
  isCreating: boolean

  // Update
  updateOrderItem: (id: string, data: {
    orderId?: string
    productId?: string
    variantId?: string
    productName?: string
    variantName?: string
    quantity?: number
    unitPrice?: number
    subtotal?: number
    productType?: string
    productMetadata?: Record<string, any>
  }) => void
  updateOrderItemAsync: (id: string, data: {
    orderId?: string
    productId?: string
    variantId?: string
    productName?: string
    variantName?: string
    quantity?: number
    unitPrice?: number
    subtotal?: number
    productType?: string
    productMetadata?: Record<string, any>
  }) => Promise<OrderItem>
  isUpdating: boolean

  // Delete
  deleteOrderItem: (id: string) => void
  deleteOrderItemAsync: (id: string) => Promise<void>
  isDeleting: boolean

  // Deprecated aliases
  loading: boolean
  refresh: () => void
}

export function useOrderItems(options: UseOrderItemsOptions = {}): UseOrderItemsReturn {
  const {
    mine = true,
    limit = 20,
    autoLoad = true,
  } = options

  const queryClient = useQueryClient()

  // Build query key
  const queryKey = ['orderitems', { mine, limit }]

  /**
   * Query: Fetch orderitems
   */
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      let result
      if (mine) {
        result = await OrderItemService.list({ limit })
      } else {
        result = await OrderItemService.list({ limit })
      }

      if (result.error) throw result.error
      return result.data?.map((data) => OrderItem.fromDatabase(data)) || []
    },
    enabled: autoLoad,
  })

  /**
   * Mutation: Create orderitem
   */
  const createMutation = useMutation({
    mutationFn: async (data: {
      orderId: string
      productId?: string
      variantId?: string
      productName: string
      variantName?: string
      quantity: number
      unitPrice: number
      subtotal: number
      productType: string
      productMetadata?: Record<string, any>
    }) => {
      const result = await OrderItemService.create(data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to create orderitem')
      return OrderItem.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orderitems'] })
    },
  })

  /**
   * Mutation: Update orderitem
   */
  const updateMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: {
      orderId?: string
      productId?: string
      variantId?: string
      productName?: string
      variantName?: string
      quantity?: number
      unitPrice?: number
      subtotal?: number
      productType?: string
      productMetadata?: Record<string, any>
    } }) => {
      const result = await OrderItemService.update(id, data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to update orderitem')
      return OrderItem.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orderitems'] })
    },
  })

  /**
   * Mutation: Delete orderitem
   */
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await OrderItemService.delete(id)
      if (result.error) throw result.error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['orderitems'] })
    },
  })

  return {
    // Query state
    orderitems: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,

    // Create
    createOrderItem: (data) => createMutation.mutate(data),
    createOrderItemAsync: (data) => createMutation.mutateAsync(data),
    isCreating: createMutation.isPending,

    // Update
    updateOrderItem: (id, data) => updateMutation.mutate({ id, data }),
    updateOrderItemAsync: (id, data) => updateMutation.mutateAsync({ id, data }),
    isUpdating: updateMutation.isPending,

    // Delete
    deleteOrderItem: (id) => deleteMutation.mutate(id),
    deleteOrderItemAsync: (id) => deleteMutation.mutateAsync(id),
    isDeleting: deleteMutation.isPending,

    // Deprecated aliases
    loading: query.isLoading,
    refresh: query.refetch,
  }
}

/**
 * useOrderItem Hook - Get single orderitem by ID
 */
export function useOrderItem(id: string, options: { autoLoad?: boolean } = {}) {
  const { autoLoad = true } = options

  const query = useQuery({
    queryKey: ['orderitem', id],
    queryFn: async () => {
      const result = await OrderItemService.getById(id)
      if (result.error) throw result.error
      return result.data ? OrderItem.fromDatabase(result.data) : null
    },
    enabled: !!id && autoLoad,
  })

  return {
    orderitem: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  }
}