/// Hook Template for Frontend (React Query)
///
/// Generates TypeScript React Hook with:
/// - useQuery for fetching data
/// - useMutation for CRUD operations
/// - Automatic cache invalidation
/// - Type-safe operations

pub const HOOK_TEMPLATE: &str = r##"/**
 * use{{ name }}s Hook (React Query)
 * Auto-generated by HEADLESS API Generator
 *
 * Manages {{ name | lower }}s state and CRUD operations
 * - React Query integration
 * - Type-safe mutations
 * - Automatic cache invalidation
 *
 * Usage:
 * ```typescript
 * const { {{ name | lower }}s, isLoading, create{{ name }}, update{{ name }}, delete{{ name }} } = use{{ name }}s()
 * ```
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { {{ name }}Service } from '../services/{{ name }}Service'
import { {{ name }} } from '../models/{{ name }}'
{%- for field in enum_fields %}
import type { {{ name }}{{ field.name | pascal_case }} } from '../models/{{ name }}'
{%- endfor %}

interface Use{{ name }}sOptions {
  /** Get only current user's {{ name | lower }}s (default: true) */
  mine?: boolean
{%- for field in enum_fields %}
  /** Filter by {{ field.name }} */
  {{ field.name }}?: {{ name }}{{ field.name | pascal_case }}
{%- endfor %}
{%- for op in operations %}
{%- if op.op_type == "custom" %}
  /** Use '{{ op.name }}' query */
  {{ op.name }}?: boolean
{%- for filter in op.filters %}
  /** Filter for {{ op.name }}: {{ filter }} */
  {{ filter }}?: string
{%- endfor %}
{%- endif %}
{%- endfor %}
  /** Limit number of results */
  limit?: number
  /** Auto-load on mount (default: true) */
  autoLoad?: boolean
}

interface Use{{ name }}sReturn {
  // Query state
  {{ name | lower }}s: {{ name }}[] | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void

  // Create
  create{{ name }}: (data: {
{%- for field in writable_fields %}
{%- if field.name != "userId" %}
    {{ field.name }}{% if not field.required %}?{% endif %}: {{ field.typescript_type }}
{%- endif %}
{%- endfor %}
  }) => void
  create{{ name }}Async: (data: {
{%- for field in writable_fields %}
{%- if field.name != "userId" %}
    {{ field.name }}{% if not field.required %}?{% endif %}: {{ field.typescript_type }}
{%- endif %}
{%- endfor %}
  }) => Promise<{{ name }}>
  isCreating: boolean

  // Update
  update{{ name }}: (id: string, data: {
{%- for field in updatable_fields %}
    {{ field.name }}?: {{ field.typescript_type }}
{%- endfor %}
  }) => void
  update{{ name }}Async: (id: string, data: {
{%- for field in updatable_fields %}
    {{ field.name }}?: {{ field.typescript_type }}
{%- endfor %}
  }) => Promise<{{ name }}>
  isUpdating: boolean

  // Delete
  delete{{ name }}: (id: string) => void
  delete{{ name }}Async: (id: string) => Promise<void>
  isDeleting: boolean
{%- for field in enum_fields %}
{%- if field.enum_values | length >= 2 %}

  // {{ field.name | pascal_case }} helpers
  set{{ field.name | pascal_case }}{{ field.enum_values[1] | pascal_case }}: (id: string) => void
  set{{ field.name | pascal_case }}{{ field.enum_values[0] | pascal_case }}: (id: string) => void
{%- endif %}
{%- endfor %}

  // Deprecated aliases
  loading: boolean
  refresh: () => void
}

export function use{{ name }}s(options: Use{{ name }}sOptions = {}): Use{{ name }}sReturn {
  const {
    mine = true,
{%- for field in enum_fields %}
    {{ field.name }},
{%- endfor %}
{%- for op in operations %}
{%- if op.op_type == "custom" %}
    {{ op.name }} = false,
{%- for filter in op.filters %}
    {{ filter }},
{%- endfor %}
{%- endif %}
{%- endfor %}
    limit = 20,
    autoLoad = true,
  } = options

  const queryClient = useQueryClient()

  // Build query key
  const queryKey = ['{{ name | lower }}s', { mine, {% for field in enum_fields %}{{ field.name }}, {% endfor %}{% for op in operations %}{% if op.op_type == "custom" %}{{ op.name }}, {% endif %}{% endfor %}limit }]

  /**
   * Query: Fetch {{ name | lower }}s
   */
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      let result
{%- set ns = namespace(first_condition = true) %}
{%- for op in operations %}
{%- if op.op_type == "custom" %}
      {% if ns.first_condition %}if{% else %}else if{% endif %} ({{ op.name }}) {
        result = await {{ name }}Service.{{ op.name }}({% if op.filters | length > 0 %}{ {% for filter in op.filters %}{{ filter }}: {{ filter }}{% if not loop.last %}, {% endif %}{% endfor %} }{% endif %})
      }
{%- set ns.first_condition = false %}
{%- endif %}
{%- endfor %}
      {% if not ns.first_condition %}else {% endif %}if (mine) {
        result = await {{ name }}Service.list({ {% for field in enum_fields %}{{ field.name }}, {% endfor %}limit })
      } else {
        result = await {{ name }}Service.list({ {% for field in enum_fields %}{{ field.name }}, {% endfor %}limit })
      }

      if (result.error) throw result.error
      return result.data?.map((data) => {{ name }}.fromDatabase(data)) || []
    },
    enabled: autoLoad,
  })

  /**
   * Mutation: Create {{ name | lower }}
   */
  const createMutation = useMutation({
    mutationFn: async (data: {
{%- for field in writable_fields %}
{%- if field.name != "userId" %}
      {{ field.name }}{% if not field.required %}?{% endif %}: {{ field.typescript_type }}
{%- endif %}
{%- endfor %}
    }) => {
      const result = await {{ name }}Service.create(data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to create {{ name | lower }}')
      return {{ name }}.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{ name | lower }}s'] })
    },
  })

  /**
   * Mutation: Update {{ name | lower }}
   */
  const updateMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: {
{%- for field in updatable_fields %}
      {{ field.name }}?: {{ field.typescript_type }}
{%- endfor %}
    } }) => {
      const result = await {{ name }}Service.update(id, data)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to update {{ name | lower }}')
      return {{ name }}.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{ name | lower }}s'] })
    },
  })

  /**
   * Mutation: Delete {{ name | lower }}
   */
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await {{ name }}Service.delete(id)
      if (result.error) throw result.error
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{ name | lower }}s'] })
    },
  })
{%- for field in enum_fields %}
{%- if field.enum_values | length >= 2 %}

  /**
   * Mutation: Set {{ field.name }} to {{ field.enum_values[1] }}
   */
  const set{{ field.name | pascal_case }}{{ field.enum_values[1] | pascal_case }}Mutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await {{ name }}Service.set{{ field.name | pascal_case }}{{ field.enum_values[1] | pascal_case }}(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set {{ field.name }} to {{ field.enum_values[1] }}')
      return {{ name }}.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{ name | lower }}s'] })
    },
  })

  /**
   * Mutation: Set {{ field.name }} to {{ field.enum_values[0] }}
   */
  const set{{ field.name | pascal_case }}{{ field.enum_values[0] | pascal_case }}Mutation = useMutation({
    mutationFn: async (id: string) => {
      const result = await {{ name }}Service.set{{ field.name | pascal_case }}{{ field.enum_values[0] | pascal_case }}(id)
      if (result.error) throw result.error
      if (!result.data) throw new Error('Failed to set {{ field.name }} to {{ field.enum_values[0] }}')
      return {{ name }}.fromDatabase(result.data)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{ name | lower }}s'] })
    },
  })
{%- endif %}
{%- endfor %}

  return {
    // Query state
    {{ name | lower }}s: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,

    // Create
    create{{ name }}: (data) => createMutation.mutate(data),
    create{{ name }}Async: (data) => createMutation.mutateAsync(data),
    isCreating: createMutation.isPending,

    // Update
    update{{ name }}: (id, data) => updateMutation.mutate({ id, data }),
    update{{ name }}Async: (id, data) => updateMutation.mutateAsync({ id, data }),
    isUpdating: updateMutation.isPending,

    // Delete
    delete{{ name }}: (id) => deleteMutation.mutate(id),
    delete{{ name }}Async: (id) => deleteMutation.mutateAsync(id),
    isDeleting: deleteMutation.isPending,
{%- for field in enum_fields %}
{%- if field.enum_values | length >= 2 %}

    // {{ field.name | pascal_case }} helpers
    set{{ field.name | pascal_case }}{{ field.enum_values[1] | pascal_case }}: (id) => set{{ field.name | pascal_case }}{{ field.enum_values[1] | pascal_case }}Mutation.mutate(id),
    set{{ field.name | pascal_case }}{{ field.enum_values[0] | pascal_case }}: (id) => set{{ field.name | pascal_case }}{{ field.enum_values[0] | pascal_case }}Mutation.mutate(id),
{%- endif %}
{%- endfor %}

    // Deprecated aliases
    loading: query.isLoading,
    refresh: query.refetch,
  }
}

/**
 * use{{ name }} Hook - Get single {{ name | lower }} by ID
 */
export function use{{ name }}(id: string, options: { autoLoad?: boolean } = {}) {
  const { autoLoad = true } = options

  const query = useQuery({
    queryKey: ['{{ name | lower }}', id],
    queryFn: async () => {
      const result = await {{ name }}Service.getById(id)
      if (result.error) throw result.error
      return result.data ? {{ name }}.fromDatabase(result.data) : null
    },
    enabled: !!id && autoLoad,
  })

  return {
    {{ name | lower }}: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  }
}
"##;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_template_syntax() {
        assert!(HOOK_TEMPLATE.contains("use{{ name }}s"));
        assert!(HOOK_TEMPLATE.contains("useQuery"));
        assert!(HOOK_TEMPLATE.contains("useMutation"));
    }
}
