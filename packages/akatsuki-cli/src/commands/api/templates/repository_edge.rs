/**
 * Repository (Edge Functions) Template (minijinja)
 * Generates TypeScript Repository for Edge Functions
 */

pub const REPOSITORY_EDGE_TEMPLATE: &str = r#"/**
 * {{ name }} Repository (Edge Functions版)
 * {{ table_name }} テーブルのCRUD操作
 *
 * Auto-generated by HEADLESS API Generator
 * - BaseRepository継承
 * - RLS対応（userClient使用）
 * - エラーハンドリング統一
 */

import { BaseRepository } from '../repository.ts'

export interface {{ name }} {
{%- for field in fields %}
  {{ field.db_name }}: {{ field.typescript_type }}
{%- endfor %}
}

export interface {{ name }}Insert {
{%- for field in writable_fields %}
  {{ field.db_name }}{% if not field.required %}?{% endif %}: {{ field.typescript_type }}
{%- endfor %}
}

export interface {{ name }}Update {
{%- for field in updatable_fields %}
  {{ field.db_name }}?: {{ field.typescript_type }}
{%- endfor %}
}

export class {{ name }}Repository extends BaseRepository {
  /**
   * Get {{ table_name|singular }} by ID
   */
  async findById(id: string): Promise<{{ name }} | null> {
    const { data, error } = await this.supabase
      .from('{{ table_name }}')
      .select('*')
      .eq('id', id)
      .single()

    if (error) {
      if (this.isNotFoundError(error)) {
        return null
      }
      throw new Error(`Failed to fetch {{ table_name|singular }}: ${error.message}`)
    }

    return data as {{ name }}
  }

  /**
   * Get {{ table_name }} by user ID
   */
  async findByUserId(
    userId: string,
    filters?: { {% for filter in list_filters %}{{ filter }}?: any{% if not loop.last %}, {% endif %}{% endfor %} }
  ): Promise<{{ name }}[]> {
    let query = this.supabase
      .from('{{ table_name }}')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })

    {%- for filter in list_filters %}
    if (filters?.{{ filter }}) {
      query = query.eq('{{ filter }}', filters.{{ filter }})
    }
    {%- endfor %}

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch user {{ table_name }}: ${error.message}`)
    }

    return (data as {{ name }}[]) || []
  }

  /**
   * Get current user's {{ table_name }}
   */
  async findMine(filters?: { {% for filter in list_filters %}{{ filter }}?: any{% if not loop.last %}, {% endif %}{% endfor %} }): Promise<{{ name }}[]> {
    const user = await this.getCurrentUser()
    return this.findByUserId(user.id, filters)
  }

  /**
   * Create {{ table_name|singular }}
   */
  async create(data: {{ name }}Insert): Promise<{{ name }}> {
    const { data: result, error } = await this.supabase
      .from('{{ table_name }}')
      .insert([data])
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create {{ table_name|singular }}: ${error.message}`)
    }

    return result as {{ name }}
  }

  /**
   * Update {{ table_name|singular }}
   */
  async update(id: string, updates: {{ name }}Update): Promise<{{ name }}> {
    const { data, error } = await this.supabase
      .from('{{ table_name }}')
      .update(updates)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update {{ table_name|singular }}: ${error.message}`)
    }

    return data as {{ name }}
  }

  /**
   * Delete {{ table_name|singular }}
   */
  async delete(id: string): Promise<void> {
    const { error } = await this.supabase.from('{{ table_name }}').delete().eq('id', id)

    if (error) {
      throw new Error(`Failed to delete {{ table_name|singular }}: ${error.message}`)
    }
  }

  /**
   * Get {{ table_name }} with filters
   */
  async findAll(filters?: {
    {%- for filter in all_filters %}
    {{ filter }}?: any
    {%- endfor %}
    limit?: number
  }): Promise<{{ name }}[]> {
    let query = this.supabase
      .from('{{ table_name }}')
      .select('*')
      .order('created_at', { ascending: false })

    {%- for filter in all_filters %}
    if (filters?.{{ filter }}) {
      {%- if filter == "tag" %}
      query = query.contains('tags', [filters.{{ filter }}])
      {%- else %}
      query = query.eq('{{ filter }}', filters.{{ filter }})
      {%- endif %}
    }
    {%- endfor %}

    if (filters?.limit) {
      query = query.limit(filters.limit)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(`Failed to fetch {{ table_name }}: ${error.message}`)
    }

    return (data as {{ name }}[]) || []
  }
{%- for op in custom_operations %}

  /**
   * {{ op.description|default(value=op.name ~ " operation") }}
   */
  async {{ op.name }}({% if op.filters|length > 0 %}filters?: { {% for filter in op.filters %}{{ filter }}?: any{% if not loop.last %}, {% endif %}{% endfor %} }{% endif %}{% if op.limit %}, limit: number = {{ op.limit }}{% endif %}): Promise<{{ name }}[]> {
    // Custom operation: {{ op.name }}
    // TODO: Implement custom logic
    return this.findAll({% if op.filters|length > 0 %}filters{% endif %})
  }
{%- endfor %}
}
"#;
